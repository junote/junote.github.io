---
layout: post
title:  "数字证书原理"
date:   2017-11-21
categories: secure 
tags: RSA
mathjax: false
---
* content
{:toc}

## 加密通信过程的演化
我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：

#### 第一回合

~~~
“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：？？？？
/*因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：*/

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“黑客”：你好        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”

“黑客”->“客户”：你好，我是服务器
~~~

因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进.

#### 第二回合

~~~
 “客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]
~~~

注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，面的示例中都用这种表示方式，例如上面的 {你好，我是服务器}[私钥|RSA]  就表示用钥对“你好，我是服务器”进行加密后的结果。

为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。

“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为由“服务器”用私钥加密后的内容，由并且只能由公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。

假设“黑客”想冒充“服务器”：

~~~
“黑客”->“客户”：你好，我是服务器

“客户”->“黑客”：向我证明你就是服务器

“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]    //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。

“客户”->“黑客”：？？？？
~~~

由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公解密的，因此可以认定对方是个冒牌货！

到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示

#### 第三回合

~~~
 “客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]

“服务器”->“客户”：{你的余额是100元}[私钥|RSA]

~~~

注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。

这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示

#### 第四回合

~~~
客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。

“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]
~~~

在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥“黑客”也无从知道对称加密算法和密钥的内容。

由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了 

服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：

a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。

b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。

但是这个两个方法都有一定的问题，

对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。

对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：

~~~

 “客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息

“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥

“客户”->“黑客”：向我证明你就是服务器

“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”
~~~

 为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：

    证书的发布机构
    证书的有效期
    公钥
    证书所有者（Subject）
    签名所使用的算法
    指纹以及指纹算法

证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下

#### 第五回合

~~~
客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]
~~~

注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾下

#### 完整过程

1. “客户”向服务端发送一个通信请求

~~~
“客户”->“服务器”：你好
~~~

2. “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有

~~~
 “服务器”->“客户”：你好，我是服务器，这里是我的数字证书 
~~~

3. “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。

~~~
 “客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。

“服务器”->“客户”：{一个随机字符串}[私钥|RSA]
~~~

4.  验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。

~~~
 “服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]

…… //继续其它的通信
~~~

## reference
1. [数字证书原理](http://blog.csdn.net/junehappylove/article/details/52288796)